function plotBatchHistory(full_history, sys_init, verbose_level)
    % plotBatchHistory Aggregates and plots the complete history from fitGreyboxInBatches.
    %
    %   This function takes the cell array 'full_history' generated by
    %   fitGreyboxInBatches and stitches all the individual batch histories
    %   together to create unified plots showing the entire fitting process.
    %
    %   Syntax:
    %       plotBatchHistory(full_history, sys_init)
    %       plotBatchHistory(full_history, sys_init, verbose_level)
    %
    %   Inputs:
    %       full_history  - The cell array output from fitGreyboxInBatches.
    %       sys_init      - The *original* idgrey model (sys_init) passed to
    %                       the fitting function. This is required to get
    %                       parameter names and initial values for normalization.
    %       verbose_level - (Optional) Controls which plots to create, matching
    %                       the logic in fitGreyboxWithHistory:
    %                         2: MSE/Loss plot
    %                         3: +Parameter evolution plot
    %                         4: +Fitting time plot
    %                       (Default: 3)
    
    arguments
        full_history  cell
        sys_init      idgrey
        verbose_level double = 3 % Default to showing MSE and Parameter plots
    end
    
    % --- 1. Aggregate Data from All Batches ---
    fprintf('Aggregating and plotting batch history...\n');
    
    % --- Configuration ---
    desired_line_width = 4;
    axis_label_font_size = 18; % Updated to match test settings
    axis_tick_font_size = 13;

    % Initialize combined history arrays
    combined_train_mse = [];
    combined_val_mse = [];
    combined_parameters = [];
    combined_time_iters = []; % This will be the global iteration axis
    combined_time_sec = [];
    combined_loss_vals = [];
    combined_loss_iters = []; % Separate iteration axis for loss
    
    global_iter_offset = 0;
    global_time_offset = 0;
    has_val_data = false;
    
    % Get the initial "zero-iteration" values from the *very first* batch
    if isempty(full_history)
        warning('History is empty. No plots will be generated.');
        return;
    end
    h_init = full_history{1}.history;
    
    combined_train_mse = [h_init.train_mse(1)];
    combined_parameters = [h_init.parameters(:, 1)];
    combined_time_iters = [0];
    combined_time_sec = [0];
    
    if isfield(h_init, 'val_mse') && ~isempty(h_init.val_mse)
        has_val_data = true;
        combined_val_mse = [h_init.val_mse(1)];
    else
        % Check subsequent histories just in case
        for i = 1:length(full_history)
            if isfield(full_history{i}.history, 'val_mse') && ~isempty(full_history{i}.history.val_mse)
                has_val_data = true;
                combined_val_mse = [NaN]; % Pad initial value
                break;
            end
        end
    end
    
    
    % Loop through all batches and append their results
    for i = 1:length(full_history)
        h = full_history{i}.history;
        
        % Get data, skipping the first (initial) point
        batch_train_mse = h.train_mse(2:end);
        batch_params = h.parameters(:, 2:end);
        batch_time_iters = h.fitting_time.iterations(2:end);
        batch_time_sec = h.fitting_time.time(2:end);
        
        if isfield(h, 'fit') && ~isempty(h.fit)
            batch_loss_vals = [h.fit.LossFcn];
            % 'fit' has no initial value, so its iterations are just batch_time_iters
            batch_loss_iters = batch_time_iters;
        else
            batch_loss_vals = [];
            batch_loss_iters = [];
        end
        
        % Append to combined arrays, applying the global offset
        combined_train_mse = [combined_train_mse, batch_train_mse];
        combined_parameters = [combined_parameters, batch_params];
        combined_time_iters = [combined_time_iters, batch_time_iters + global_iter_offset];
        combined_time_sec = [combined_time_sec, batch_time_sec + global_time_offset];
        
        combined_loss_vals = [combined_loss_vals, batch_loss_vals];
        combined_loss_iters = [combined_loss_iters, batch_loss_iters + global_iter_offset];
    
        if has_val_data
            if isfield(h, 'val_mse') && ~isempty(h.val_mse)
                batch_val_mse = h.val_mse(2:end);
                combined_val_mse = [combined_val_mse, batch_val_mse];
            else
                % Pad with NaN if this batch was missing validation data
                combined_val_mse = [combined_val_mse, nan(size(batch_train_mse))];
            end
        end
                
        % Update offsets for the *next* loop
        if ~isempty(h.fitting_time.iterations)
            global_iter_offset = global_iter_offset + h.fitting_time.iterations(end);
            global_time_offset = global_time_offset + h.fitting_time.time(end);
        end
    end
    
    % --- 2. Generate Plots (based on logic from fitGreyboxWithHistory) ---
    
    if verbose_level >= 2
        % Plot 1: MSE and Loss
        figure('Name', 'MSE and Loss');
        
        % Plot 1.1: MSE
        subplot(2, 1, 1);
        semilogy(combined_time_iters, combined_train_mse, '.-', 'LineWidth', desired_line_width);
        set(gca, 'FontSize', axis_tick_font_size); % Set Ticks FIRST
        title('Calculated MSE versus Total Iterations');
        xlabel('Total Iterations', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        ylabel('MSE', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        grid on;
        hold on;
        
        if has_val_data
            semilogy(combined_time_iters, combined_val_mse, '.--', 'LineWidth', desired_line_width);
            legend('Training MSE', 'Validation MSE');
        else
            legend('Training MSE');
        end
        hold off;
        
        % Plot 1.2: Loss
        subplot(2, 1, 2);
        if ~isempty(combined_loss_iters)
            semilogy(combined_loss_iters, combined_loss_vals, '.-', 'LineWidth', desired_line_width);
            set(gca, 'FontSize', axis_tick_font_size); % Set Ticks FIRST
            title('Loss Function versus Total Iterations');
            xlabel('Total Iterations', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
            ylabel('Loss Value', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
            grid on;
        else
            title('Loss Function (No Data)');
        end
    end
    
    if verbose_level >= 3
        % Plot 2: Normalized Parameter Evolution
        
        % Get initial parameters for normalization
        params_init = getpvec(sys_init);
        params_init(params_init == 0) = eps; % Avoid div by zero
        
        % Normalize the combined parameter history
        % combined_parameters is [P x N], params_init is [P x 1]
        normalized_params = combined_parameters ./ params_init;
        param_names = {sys_init.Structure.Parameters.Name};
        
        figure('Name', 'Parameter Evolution');
        % semilogy plots each column of the 2nd arg vs. the 1st arg vector
        % Our parameters are in *rows*, so we plot the transpose
        semilogy(combined_time_iters, normalized_params, 'LineWidth', desired_line_width);
        set(gca, 'FontSize', axis_tick_font_size); % Set Ticks FIRST
        %title('Normalized Parameter Evolution');
        xlabel('Total Iterations', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        ylabel('Normalized Value', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        grid on;
        %legend(param_names, 'Interpreter', 'none');
        legend(param_names, 'Interpreter', 'none', 'Location', 'Best');% Best, SouthWest, SouthEast, NorthWest, NorthEast, BestOutside, EastOutside, NorthEastOutside, NorthWestOutside, SouthEastOutside, SouthWestOutside
    end
    
    if verbose_level >= 4
        % Plot 3: Fitting Time vs. Iterations
        
        % Fit a polynomial to the combined time history
        p_fit = polyfit(combined_time_iters, combined_time_sec, 2);
        y_fit = polyval(p_fit, combined_time_iters);
        
        figure('Name', 'Fitting Time');
        hold on;
        plot(combined_time_iters, combined_time_sec, '.-', 'LineWidth', desired_line_width);
        plot(combined_time_iters, y_fit, 'r--', 'LineWidth', desired_line_width);
        hold off;
        set(gca, 'FontSize', axis_tick_font_size); % Set Ticks FIRST
        title('Fitting Time versus Total Iterations');
        xlabel('Total Iterations', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        ylabel('Time (s)', 'FontSize', axis_label_font_size, 'FontWeight', 'bold');
        grid on;
        legend('Cumulative Time', 'Polynomial Fit');
    end
    
    fprintf('Batch history plotting complete.\n');

end